'use strict';

const fs = require('fs');

let rawdata = fs.readFileSync('ls.json');
let listing = JSON.parse(rawdata);
const gitstuffFilename = "gitstuff.bat";
const packageGitignore = "../.gitignore";
let extraLibGitignore = "";
let gitstuff = "cd ..\n";
let libgitignore = null;

DoThese([
	prepareToAddToGitignore,
	writePackageJsonFiles,
	writeBatchfile,
	writeGitignore,
	function(callback) { console.log(_colorCyan("finished package metadata compile")); callback(null); }
]);

function DoThese(thingsToDo){
	function DoThem(err) {
		if (!err) {
			if (thingsToDo.length == 0) { return; }
			let nextThing = thingsToDo[0];
			thingsToDo = thingsToDo.slice(1);
			//console.log(`about to do thing ${thingsToDoIndex}: ${thingsToDo[thingsToDoIndex]}`);
			nextThing(DoThem);
		} else {
			throw err;
		}
	}
	DoThem();
}

function prepareToAddToGitignore(callback) {
	fs.readFile(packageGitignore, 'utf8' , (err, data) => {
		if (err) {
			console.error(err);
			callback();
			return;
		}
		libgitignore = data.split('\n');
		for(let i = 0; i < libgitignore.length; i++) {
			libgitignore[i] = libgitignore[i].replace(/\r/g, "");
		}
		console.log(`${_colorCyan("found")} ${packageGitignore}`);
		callback();
	});
}
function _colorCyan(str) { return `\x1b[36m${str}\x1b[0m`; }
function _colorGreen(str) { return `\x1b[32m${str}\x1b[0m`; }
function writePackageJsonFiles(callback) {
	let written = 0, toWrite = 0;
	let writtenFolders = [];
	for (const [key, value] of Object.entries(listing)) {
		if (value.listed === false) { continue; }
		//console.log(`${key}: ${value}`);
		let folderName = GetFolderName(value);
		let packageFolder = `../${folderName}`
		let packagePath = packageFolder + '/package.json';
		let packageText = CreatePackageFileData(value,listing);
		gitstuff += `call git clone ${value.url}\n`;
		let extraIgnoreEntry = `${folderName}/`;
		if (libgitignore == null || libgitignore.indexOf(extraIgnoreEntry) < 0) {
			console.log(".gitignore does not contain "+extraIgnoreEntry);
			extraLibGitignore += extraIgnoreEntry + "\n";
		}
		++toWrite;
		writtenFolders.push(folderName);
		fs.writeFile(packagePath, packageText, err => {
			++written;
			if (err) { console.error(err); return; }
			if (written == toWrite){
				console.log(`${_colorCyan("wrote packages")} ${writtenFolders.join(", ")}`);
				callback();
			}
		});
	}
}
function writeBatchfile(callback) {
	fs.writeFile(gitstuffFilename, gitstuff, err => {
		if (err) { console.error(err); reject(err); return; }
		console.log(`${_colorCyan("wrote")} ${gitstuffFilename}`);
		callback();
	});
}
function writeGitignore(callback) {
	if (extraLibGitignore.length > 0) {
		console.log(`adding .gitignore entries:\n${extraLibGitignore}`);
		let finalAddendum = `# NonStandard library\n${extraLibGitignore}`;
		fs.appendFile(packageGitignore, finalAddendum, function (err) {
			if (err) { callback(err); throw err; }
			console.log(`${_colorCyan("updated")} ${packageGitignore}`);
			callback();
		});
	} else {
		console.log(_colorGreen(`${packageGitignore} already up to date`));
		callback();
	}
}

// line escape converter, so strings can be passed into other string input
function lnesc(text) { return text.replace(/\n/g, "\\n").replace(/\"/g, "\\\"").replace(/\'/g, "\\\'").replace(/\t/g, "\\t"); }

function GetFolderName(packageData) { 
	let fullname = packageData.url;
	let indexSlash = fullname.lastIndexOf("/");
	let indexDot = fullname.lastIndexOf(".git");
	return fullname.substring(indexSlash+1, indexDot);
}

function CreatePackageFileData(packageData, listing) {
	const infoHeader = "NonStandard library imported using NonStandard package management";
	let name = packageData.name;
	let id = packageData.id;
	let desc = packageData.desc ? infoHeader + "\n\n" + packageData.desc : infoHeader;
	let dependencies = [];
	if (packageData.req) {
		for (const [key,value] of Object.entries(packageData.req)) {
			let dep = listing[value];
			if (!dep) {
				console.log(`missing dependency '${value}'`);
				continue;
			}
			dependencies.push(dep);
		}
	}
	let dependenciesVersionString = (dependencies.length > 0 ? "{\n" : "{}");
	dependencies.forEach((d, i) => {
		dependenciesVersionString += `\t\t\"${d.id}\": \"${d.v}\"`;
		if (i < dependencies.length-1) {
			dependenciesVersionString += '",\n';
		} else {
			dependenciesVersionString += '"\n\t}';
		}
	});
	let author = "Michael Vaganov";
	let email = "mvaganov@gmail.com";
	let authorurl = "https://github.com/mvaganov/NonStandard";
	let version = packageData.v ? packageData.v : "1.0.0";
	let keywords = packageData.keywords ? packageData.keywords : ["library", "NonStandard"];
	let keywordsString = `[\n		"${keywords.join('",\n		"')}"\n	]`;
	var packageTemplate =
`{
	"@comment package": ["autogenerated by the compile.js script in NonStandard"],
	"name": "${id}",
	"version": "${version}",
	"displayName": "${name}",
	"description": "${lnesc(desc)}.",
	"unity": "2019.4",
	"dependencies": ${dependenciesVersionString},
	"keywords": ${keywordsString},
	"author": {
		"name": "${author}",
		"email": "${email}",
		"url": "${authorurl}"
	},
	"type": "library"
}`;
	return packageTemplate;
}
