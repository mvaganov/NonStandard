'use strict';

const fs = require('fs');

let rawdata = fs.readFileSync('ls.json');
let listing = JSON.parse(rawdata);
const gitstuffFilename = "gitstuff.bat";
const packageGitignore = "../.gitignore";
let extraLibGitignore = "";
let gitstuff = "cd ..\n";
let libgitignore = null;

const updateGitignoreAndPackageFiles = new Promise((resolve0, reject0) => {
	fs.readFile(packageGitignore, 'utf8' , (err, data) => {
		if (err) {
			console.error(err);
			resolve0();
			return;
		}
		libgitignore = data.split('\n');
		for(let i = 0; i < libgitignore.length; i++) {
			libgitignore[i] = libgitignore[i].replace(/\r/g, "");
		}
		console.log(`found ${packageGitignore}`);
		resolve0();
	});
}).then((resolve1,reject1) => {
	GeneratePackages();
});

function GeneratePackages() {
	for (const [key, value] of Object.entries(listing)) {
		if (value.listed === false) { continue; }
		//console.log(`${key}: ${value}`);
		let folderName = GetFolderName(value);
		let packageFolder = `../${folderName}`
		let packagePath = packageFolder + '/package.json';
		let packageText = CreatePackageFileData(value,listing);
		gitstuff += `call git clone ${value.url}\n`;
		let extraIgnoreEntry = `${folderName}/`;
		if (libgitignore == null || libgitignore.indexOf(extraIgnoreEntry) < 0) {
			console.log(".gitignore does not contain "+extraIgnoreEntry);
			extraLibGitignore += extraIgnoreEntry + "\n";
		}
		fs.writeFile(packagePath, packageText, err => {
			if (err) { console.error(err); return; }
			console.log(`wrote ${packagePath}`);
		});
	}
	fs.writeFile(gitstuffFilename, gitstuff, err => {
		if (err) { console.error(err); return; }
		console.log(`wrote ${gitstuffFilename}`);
	});
	if (extraLibGitignore.length > 0) {
		console.log(`adding .gitignore entries:\n${extraLibGitignore}`);
		let finalAddendum = `# NonStandard library\n${extraLibGitignore}`;
		fs.appendFile(packageGitignore, finalAddendum, function (err) {
			if (err) throw err;
			console.log(`updated ${packageGitignore}`);
		});
	} else {
		console.log(`${packageGitignore} already up to date`);
	}
}

// line escape converter, so strings can be passed into other string input
function lnesc(text) { return text.replace(/\n/g, "\\n").replace(/\"/g, "\\\"").replace(/\'/g, "\\\'").replace(/\t/g, "\\t"); }

function GetFolderName(packageData) { 
	let fullname = packageData.url;
	let indexSlash = fullname.lastIndexOf("/");
	let indexDot = fullname.lastIndexOf(".git");
	return fullname.substring(indexSlash+1, indexDot);
}

function CreatePackageFileData(packageData, listing) {
	const infoHeader = "NonStandard library imported using NonStandard package management";
	let name = packageData.name;
	let id = packageData.id;
	let desc = packageData.desc ? infoHeader + "\n\n" + packageData.desc : infoHeader;
	let dependencies = [];
	if (packageData.req) {
		for (const [key,value] of Object.entries(packageData.req)) {
			let dep = listing[value];
			if (!dep) {
				console.log(`missing dependency '${value}'`);
				continue;
			}
			dependencies.push(dep);
		}
	}
	let dependenciesVersionString = (dependencies.length > 0 ? "{\n" : "{}");
	dependencies.forEach((d, i) => {
		dependenciesVersionString += `\t\t\"${d.id}\": \"${d.v}\"`;
		if (i < dependencies.length-1) {
			dependenciesVersionString += '",\n';
		} else {
			dependenciesVersionString += '"\n\t}';
		}
	});
	let author = "Michael Vaganov";
	let email = "mvaganov@gmail.com";
	let authorurl = "https://github.com/mvaganov/NonStandard";
	let version = packageData.v ? packageData.v : "1.0.0";
	let keywords = packageData.keywords ? packageData.keywords : ["library", "NonStandard"];
	let keywordsString = `[\n		"${keywords.join('",\n		"')}"\n	]`;
	var packageTemplate =
`{
	"@comment package": ["autogenerated by the compile.js script in NonStandard"],
	"name": "${id}",
	"version": "${version}",
	"displayName": "${name}",
	"description": "${lnesc(desc)}.",
	"unity": "2019.4",
	"dependencies": ${dependenciesVersionString},
	"keywords": ${keywordsString},
	"author": {
		"name": "${author}",
		"email": "${email}",
		"url": "${authorurl}"
	},
	"type": "library"
}`;
	return packageTemplate;
}
